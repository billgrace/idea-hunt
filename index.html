<!DOCTYPE html>
<html>
	<head>
		<title>Idea Hunt 0.3</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style type="text/css">
			body {
				margin: 0px;
				background-color: #fff;
				overflow: hidden;
			}
		</style>
	</head>
	<body>
		<script type="text/javascript" src="three.min.js"></script>
		<script type="text/javascript" src="stats.min.js"></script>
		<script type="text/javascript" src="controls.js"></script>
		<script type="text/javascript">
			var testLabelCore;
			var testSliderCore;
			var testBigSlider;
			var counter, leftValue, rightValue;
			var scene, renderer;
			var devMsg;
			var viewCamera, viewCamLight, viewBackgroundColor;
			var navCamera, navCamLight, navBackgroundColor;
			var selfCamera, selfCamLight, selfBackgroundColor;
			var windowWidth, windowHeight;
			var viewWindowWidth, viewWindowHeight, viewWindowLeft, viewWindowTop, viewWindowBottom, viewWindowRight;
			var navWindowWidth, navWindowHeight, navWindowLeft, navWindowTop, navWindowBottom, navWindowRight;
			var selfWindowWidth, selfWindowHeight, selfWindowLeft, selfWindowTop, selfWindowBottom, selfWindowRight;
			var coreWindowContainer, coreWindowWidth, coreWindowHeight, coreWindowLeft, coreWindowTop, coreWindowBottom, coreWindowRight;
			var optHWindowContainer, optHWindowWidth, optHWindowHeight, optHWindowLeft, optHWindowTop, optHWindowBottom, optHWindowRight;
			var optVWindowContainer, optVWindowWidth, optVWindowHeight, optVWindowLeft, optVWindowTop, optVWindowBottom, optVWindowRight;
			var topicHorizonMesh, topicHorizonTexture;
			var platformMesh;
			var launcherMesh;
			var selfGeometry, selfMaterial, selfMesh;
			var t3Controls;
			init();
			animate();
			function showClickHandler1() {
				devMsg.innerHTML = "1";
			}
			function showClickHandler2() {
				devMsg.innerHTML = "2";
			}
			function showClickHandler3() {
				devMsg.innerHTML = "3";
			}
			function showSliderChange( argument ) {
				devMsg.innerHTML = "Slider moved to " + argument.toFixed( 2 );
			}
			function init() {
				scene = new THREE.Scene();
				var rightLight = new THREE.DirectionalLight( 0x888888 );
				rightLight.position.set( 1, 0, 0 ).normalize();
				scene.add(rightLight);
				var leftLight = new THREE.DirectionalLight( 0x888888 );
				leftLight.position.set( -1, 0, 0 ).normalize();
				scene.add(leftLight);
				var bottomLight = new THREE.DirectionalLight( 0x888888 );
				bottomLight.position.set( 0, -1, 0 ).normalize();
				scene.add(bottomLight);
				renderer = new THREE.WebGLRenderer();
				document.body.appendChild( renderer.domElement );
				renderer.domElement.id = "rendererDomElement";

				viewBackgroundColor = new THREE.Color().setRGB( 0.1, 0.8, 0.1 );
				viewCamera = new THREE.PerspectiveCamera( 50, 1.3, 1, 10000 );
				viewCamera.position.set( 0, 100, 700 );
				viewCamera.rotation.x = -Math.PI/10;
				viewCamLight = new THREE.DirectionalLight( 0x888888 );
				viewCamLight.position.copy( viewCamera.position );
				viewCamLight.rotation.copy( viewCamera.rotation );
				scene.add( viewCamLight );

				navBackgroundColor = new THREE.Color().setRGB( 0.1, 0.2, 0.7 );
				navCamera = new THREE.PerspectiveCamera( 60, 1.3, 1, 10000 );
				navCamera.position.set( 0, 1200, 0 );
				navCamera.rotation.x = -Math.PI/2;
				navCamLight = new THREE.DirectionalLight( 0x888888 );
				navCamLight.position.copy( navCamera.position );
				navCamLight.rotation.copy( navCamera.rotation );
				scene.add( navCamLight );

				selfBackgroundColor = new THREE.Color().setRGB( 0.1, 0.7, 0.9 );
				selfCamera = new THREE.PerspectiveCamera( 15, 1.3, 1, 10000 );
				selfCamera.position.set( 0, 0, -1000 );
				selfCamera.rotation.y = Math.PI;
				selfCamLight = new THREE.DirectionalLight( 0x888888 );
				selfCamLight.position.copy( selfCamera.position );
				selfCamLight.rotation.copy( selfCamera.rotation );
				scene.add( selfCamLight );

				coreWindowContainer = document.createElement( "div" );
				coreWindowContainer.id = "core";
				coreWindowContainer.style.cssText = "position:absolute;border-style:solid;border-width:1px;border-color:#c0c;background-color:#808";
				document.body.appendChild( coreWindowContainer );
				coreWindowContainer.innerHTML = "Core controls";
				optHWindowContainer = document.createElement( "div" );
				optHWindowContainer.id = "opth";
				optHWindowContainer.style.cssText = "position:absolute;border-style:solid;border-width:1px;border-color:#0cc;background-color:#088";
				document.body.appendChild( optHWindowContainer );
				optHWindowContainer.innerHTML = "Horizontally oriented options";
				optVWindowContainer = document.createElement( "div" );
				optVWindowContainer.id = "optv";
				optVWindowContainer.style.cssText = "position:absolute;border-style:solid;border-width:1px;border-color:#cc0;background-color:#880";
				document.body.appendChild( optVWindowContainer );
				optVWindowContainer.innerHTML = "Vertically oriented options";

				topicHorizonTexture = THREE.ImageUtils.loadTexture( 'GrndCnynFull.jpg', render );
				topicHorizonMesh = new THREE.Mesh(
					new THREE.BoxGeometry( 4000, 3000, 4000 ),
					new THREE.MeshBasicMaterial( { map: topicHorizonTexture, side:THREE.DoubleSide } ) );
				topicHorizonMesh.position.set( 0, 0, -300 );
				platformMesh = new THREE.Mesh(
					new THREE.BoxGeometry( 200, 50, 200 ),
					new THREE.MeshLambertMaterial( { color:0x00ff00 } ) );
				platformMesh.position.set( 0, -50, 100 );

				var launcherMeshTexture = THREE.ImageUtils.loadTexture( 'GrndCnynFull.jpg', render );
				var launcherMeshMaterial = new THREE.MeshBasicMaterial( { map: launcherMeshTexture } );
				launcherMesh = new THREE.Mesh(
					new THREE.CylinderGeometry( 25, 25, 150 ),
					new THREE.MeshLambertMaterial( { color:0xff0000 } ) );
				launcherMesh.position.set( 0, 0, 125 );
				launcherMesh.rotation.x = Math.PI / 2;
				var selfMaterialArray = [];
				selfMaterialArray.push(new THREE.MeshBasicMaterial( {map: THREE.ImageUtils.loadTexture( 'art/SelfRightV0.jpg' ) }));
				selfMaterialArray.push(new THREE.MeshBasicMaterial( {map: THREE.ImageUtils.loadTexture( 'art/SelfLeftV0.jpg' ) }));
				selfMaterialArray.push(new THREE.MeshBasicMaterial( {map: THREE.ImageUtils.loadTexture( 'art/SelfTopV0.jpg' ) }));
				selfMaterialArray.push(new THREE.MeshBasicMaterial( {map: THREE.ImageUtils.loadTexture( 'art/SelfBottomV0.jpg' ) }));
				selfMaterialArray.push(new THREE.MeshBasicMaterial( {map: THREE.ImageUtils.loadTexture( 'art/SelfRearV0.jpg' ) }));
				selfMaterialArray.push(new THREE.MeshBasicMaterial( {map: THREE.ImageUtils.loadTexture( 'art/SelfFrontV0.jpg' ) }));
				var selfMeshMaterial = new THREE.MeshFaceMaterial(selfMaterialArray);
				var selfMeshGeometry = new THREE.BoxGeometry( 50, 100, 56 );
				selfMesh = new THREE.Mesh( selfMeshGeometry, selfMeshMaterial );
				selfMesh.position.set( 0, 0, -100 );
				scene.add( topicHorizonMesh );
				scene.add( platformMesh );
				scene.add( launcherMesh );
				scene.add( selfMesh );

				stats = new Stats();
				stats.domElement.style.position = "absolute";
				stats.domElement.style.top = "0px";
				document.body.appendChild( stats.domElement );
				devMsg = document.createElement( "div" );
				devMsg.style.cssText = "position:absolute;border-style:solid;border-width:1px;border-color:#c00;background-color:#f88";
				devMsg.style.left = stats.domElement.style.width;
				devMsg.style.height = "20px";
				devMsg.style.top = "0px";
				document.body.appendChild( devMsg );

				updateRenderingGeometry();
				render();

				window.addEventListener( "resize", onWindowResize, false );
				window.addEventListener( "orientationchange", onWindowResize, false );

				function trapOuterTouches( e ) {
					if( nowTracking )
						e.preventDefault();
				}

				var testButtonCore = new imageButton( "art/yellowButton.png", "core", 0.1, 0.2, 0.2, 0.2, "-", showClickHandler1 );
				horizontalTestLabel = new imageLabel( "art/HLabel.jpg", "opth", 0.1, 0.2, 0.5, 0.3 );
				verticalTestLabel = new imageLabel( "art/VLabel.jpg", "optv", 0.1, 0.2, 0.2, 0.4 );

				leftValue = 0; rightValue = 100;
				counter = 0;
				testSliderCore = new horizontalSlider( "art/Slider1.png", "#440044", leftValue, rightValue, 25, "core", 0.3, 0.1, 0.2, 0.6, 0.5, showSliderChange );
				testSliderOptV = new verticalSlider( "art/Slider1.png", "#660088", 0, 250, 25, "optv", 0.3, 0.1, 0.2, 0.6, 0.5, showSliderChange );

//				var testButtonOptH = new imageButton( "art/yellowButton.png", "opth", 0.7, 0.3, 0.2, 0.2, "H", showClickHandler2 );
				var testButtonOptH = new imageButton( "art/yellowButton.png", "opth", 0.7, 0.3, 0.2, 0.2, "H", testSliderCore.deactivate );
//				var testButtonOptV = new imageButton( "art/yellowButton.png", "optv", 0.3, 0.7, 0.2, 0.2, "W", showClickHandler3 );
				var testButtonOptV = new imageButton( "art/yellowButton.png", "optv", 0.3, 0.7, 0.2, 0.2, "W", testSliderCore.activate );

			}
			function updateRenderingGeometry() {
				var windowLeftSegmentPercent;
				var windowRightSegmentPercent;
				var windowMidRightSegmentPercent;
				var windowTopSegmentPercent;
				var windowBottomSegmentPercent;
				var windowNavHeightPercent;
				var windowSelfHeightPercent;
				var Aspect;
				windowWidth = window.innerWidth;
				windowHeight = window.innerHeight;
				Aspect = windowWidth / windowHeight;
				if( Aspect > 2 ) {
					// >1.5 => very wide window
					devMsg.innerHTML = "Wide layout";
					windowLeftSegmentPercent = 20;
					windowRightSegmentPercent = 10;
					windowMidRightSegmentPercent = 15;
					windowNavHeightPercent = 50;
					navWindowHeight = ( ( windowHeight * windowNavHeightPercent ) / 100 ) | 0;
					navWindowWidth = ( ( windowWidth * windowLeftSegmentPercent ) / 100 ) | 0;
					navWindowLeft = 0;
					navWindowTop = 0;
					selfWindowHeight = windowHeight - navWindowHeight;
					selfWindowWidth = navWindowWidth;
					selfWindowLeft = 0;
					selfWindowTop = navWindowHeight;
					optVWindowWidth = ( ( windowWidth * windowRightSegmentPercent ) / 100 ) | 0;
					optVWindowHeight = windowHeight;
					optVWindowLeft = windowWidth - optVWindowWidth;
					optVWindowTop = 0;
					optHWindowHeight = navWindowHeight;
					optHWindowWidth = ( ( windowWidth * windowMidRightSegmentPercent ) / 100 ) | 0;
					optHWindowLeft = windowWidth - optVWindowWidth - optHWindowWidth;
					optHWindowTop = 0;
					coreWindowHeight = selfWindowHeight;
					coreWindowWidth = optHWindowWidth;
					coreWindowTop = selfWindowTop;
					coreWindowLeft = optHWindowLeft;
					viewWindowLeft = navWindowWidth;
					viewWindowTop = 0;
					viewWindowWidth = windowWidth - navWindowWidth - optVWindowWidth - optHWindowWidth;
					viewWindowHeight = windowHeight;
				} else if ( Aspect > 0.9 ) {
					// 0.9..2 => "normal" window ranging from squarish to typically width dominant
					devMsg.innerHTML = "Standard layout";
					windowLeftSegmentPercent = 20;
					windowRightSegmentPercent = 10;
					windowNavHeightPercent = 40;
					windowSelfHeightPercent = 40;
					navWindowHeight = ( ( windowHeight * windowNavHeightPercent ) / 100 ) | 0;
					navWindowWidth = ( ( windowWidth * windowLeftSegmentPercent ) / 100 ) | 0;
					navWindowLeft = 0;
					navWindowTop = 0;
					selfWindowHeight = ( ( windowHeight * windowSelfHeightPercent ) / 100 ) | 0;
					selfWindowWidth = navWindowWidth;
					selfWindowLeft = 0;
					selfWindowTop = navWindowHeight;
					coreWindowHeight = windowHeight - navWindowHeight - selfWindowHeight;
					coreWindowWidth = navWindowWidth;
					coreWindowLeft = 0;
					coreWindowTop = navWindowHeight + selfWindowHeight;
					optVWindowWidth = ( ( windowWidth * windowRightSegmentPercent ) / 100 ) | 0;
					optVWindowHeight = windowHeight;
					optVWindowLeft = windowWidth - optVWindowWidth;
					optVWindowTop = 0;
					optHWindowHeight = coreWindowHeight;
					optHWindowWidth = windowWidth - navWindowWidth - optVWindowWidth;
					optHWindowLeft = coreWindowWidth;
					optHWindowTop = coreWindowTop;
					viewWindowLeft = navWindowWidth;
					viewWindowTop = 0;
					viewWindowWidth = windowWidth - navWindowWidth - optVWindowWidth;
					viewWindowHeight = windowHeight - optHWindowHeight;
				} else {
					// < 0.9 => essentially vertical window
					devMsg.innerHTML = "Narrow layout";
					windowLeftSegmentPercent = 30;
					windowRightSegmentPercent = 15;
					windowTopSegmentPercent = 55;
					windowBottomSegmentPercent = 15;
					viewWindowLeft = 0;
					viewWindowTop = 0;
					viewWindowWidth = windowWidth;
					viewWindowHeight = ( ( windowHeight * windowTopSegmentPercent ) / 100 ) | 0;
					optVWindowWidth = ( ( windowWidth * windowRightSegmentPercent ) / 100 ) | 0;
					optVWindowHeight = windowHeight - viewWindowHeight;
					optVWindowLeft = windowWidth - optVWindowWidth;
					optVWindowTop = viewWindowHeight;
					coreWindowHeight = ( ( windowHeight * windowBottomSegmentPercent ) / 100 ) | 0;
					coreWindowWidth = ( ( windowWidth * windowLeftSegmentPercent ) / 100 ) | 0;
					coreWindowTop = windowHeight - coreWindowHeight;
					coreWindowLeft = 0;
					optHWindowHeight = coreWindowHeight;
					optHWindowWidth = windowWidth - optVWindowWidth - coreWindowWidth;
					optHWindowLeft = coreWindowWidth;
					optHWindowTop = coreWindowTop;
					navWindowHeight = windowHeight - viewWindowHeight - coreWindowHeight;
					navWindowWidth = ( ( windowWidth -  optVWindowWidth ) / 2 ) | 0;
					navWindowLeft = 0;
					navWindowTop = viewWindowHeight;
					selfWindowHeight = navWindowHeight;
					selfWindowWidth = windowWidth - optVWindowWidth - navWindowWidth;
					selfWindowLeft = navWindowWidth;
					selfWindowTop = navWindowTop;
				}
				viewWindowBottom = viewWindowTop + viewWindowHeight;
				viewWindowRight = viewWindowLeft + viewWindowWidth;
				navWindowBottom = navWindowTop + navWindowHeight;
				navWindowRight = navWindowLeft + navWindowWidth;
				selfWindowBottom = selfWindowTop + selfWindowHeight;
				selfWindowRight = selfWindowLeft + selfWindowWidth;
				coreWindowBottom = coreWindowTop + coreWindowHeight;
				coreWindowRight = coreWindowLeft + coreWindowWidth;
				optHWindowBottom = optHWindowTop + optHWindowHeight;
				optHWindowRight = optHWindowLeft + optHWindowWidth;
				optVWindowBottom = optVWindowTop + optVWindowHeight;
				optVWindowRight = optVWindowLeft + optVWindowWidth;
				coreWindowContainer.style.left = "0"+coreWindowLeft+"px";
				coreWindowContainer.style.top = "0"+coreWindowTop+"px";
				coreWindowContainer.style.width = "0"+coreWindowWidth+"px";
				coreWindowContainer.style.height = "0"+coreWindowHeight+"px";
				optHWindowContainer.style.left = "0"+optHWindowLeft+"px";
				optHWindowContainer.style.top = "0"+optHWindowTop+"px";
				optHWindowContainer.style.width = "0"+optHWindowWidth+"px";
				optHWindowContainer.style.height = "0"+optHWindowHeight+"px";
				optVWindowContainer.style.left = "0"+optVWindowLeft+"px";
				optVWindowContainer.style.top = "0"+optVWindowTop+"px";
				optVWindowContainer.style.width = "0"+optVWindowWidth+"px";
				optVWindowContainer.style.height = "0"+optVWindowHeight+"px";
			}
			function onWindowResize() {
				updateRenderingGeometry();
				render();
			}
			function animate() {
				render();
				stats.update();
				requestAnimationFrame( animate );
			}
			function render() {
				renderer.setSize( window.innerWidth, window.innerHeight );

				renderer.setViewport( viewWindowLeft, windowHeight - viewWindowBottom, viewWindowWidth, viewWindowHeight );
				renderer.setScissor( viewWindowLeft, windowHeight - viewWindowBottom, viewWindowWidth, viewWindowHeight );
				renderer.enableScissorTest( true );
				renderer.setClearColor( viewBackgroundColor );
				viewCamera.aspect = viewWindowWidth/viewWindowHeight;
				viewCamera.lookAt( topicHorizonMesh.position );
				viewCamera.updateProjectionMatrix();
				renderer.render( scene, viewCamera );

				renderer.setViewport( navWindowLeft, windowHeight - navWindowBottom, navWindowWidth, navWindowHeight );
				renderer.setScissor( navWindowLeft, windowHeight - navWindowBottom, navWindowWidth, navWindowHeight );
				renderer.enableScissorTest( true );
				renderer.setClearColor( navBackgroundColor );
				navCamera.aspect = navWindowWidth/navWindowHeight;
				navCamera.updateProjectionMatrix();
				renderer.render( scene, navCamera );

				renderer.setViewport( selfWindowLeft, windowHeight - selfWindowBottom, selfWindowWidth, selfWindowHeight );
				renderer.setScissor( selfWindowLeft, windowHeight - selfWindowBottom, selfWindowWidth, selfWindowHeight );
				renderer.enableScissorTest( true );
				renderer.setClearColor( selfBackgroundColor );
				selfCamera.aspect = selfWindowWidth/selfWindowHeight;
				selfCamera
				renderer.render( scene, selfCamera );
			}
		</script>
	</body>
</html>
